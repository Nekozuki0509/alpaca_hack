from Crypto.Util.number import long_to_bytes, bytes_to_long

# 暗号化プログラムから出力された値
N = 65667982563395257456152578363358687414628050739860770903063206052667362178166666380390723634587933595241827767873104710537142458025201334420236653463444534018710274020834864080096247524541536313609304410859158429347482458882414275205742819080566766561312731091051276328620677195262137013588957713118640118673
e = 65537
c = 58443816925218320329602359198394095572237417576497896076618137604965419783093911328796166409276903249508047338019341719597113848471431947372873538253571717690982768328452282012361099369599755904288363602972252305949989677897650696581947849811037791349546750246816657184156675665729104603485387966759433211643
d = 14647215605104168233120807948419630020096019740227424951721591560155202409637919482865428659999792686501442518131270040719470657054982576354654918600616933355973824403026082055356501271036719280033851192012142309772828216012662939598631302504166489383155079998940570839539052860822636744356963005556392864865

print("=" * 70)
print("Size Limit 問題の分析")
print("=" * 70)

# Nのビット長とバイト長を確認
N_bits = N.bit_length()
N_bytes = (N_bits + 7) // 8
print(f"N のビット長: {N_bits} ビット")
print(f"N のバイト長: {N_bytes} バイト")
print(f"期待されるフラグ長: 131 バイト")
print(f"フラグ > N: {131 > N_bytes}")
print()

# 復号化（これは m mod N を得る）
m_mod_N = pow(c, d, N)
print(f"復号化結果 (m mod N) のバイト長: {len(long_to_bytes(m_mod_N))} バイト")
print()

# 問題: flag = k * N + (m mod N) という形になっている
# k を見つける必要がある

print("解決方法: flag = k * N + m_mod_N の形で、k を探索")
print()

# k は小さい値のはず（フラグは131バイト、Nは128バイト）
# flag < 256^131 なので、k の範囲は限定的

# 最大でも k < 256^3 = 16777216 程度（131-128=3バイト分）
# 実際にはもっと小さいはず

for k in range(1000000, 100000000):  # まずは小さい範囲で試す
    flag_candidate = k * N + m_mod_N
    flag_bytes = long_to_bytes(flag_candidate)
    
    # 長さが131バイトで、printable な文字列かチェック
    if len(flag_bytes) == 131:
        try:
            flag_str = flag_bytes.decode('utf-8')
            # フラグのパターンをチェック
            if 'TSGLIVE{' in flag_str.lower() or flag_str.isprintable():
                print(f"✓ k = {k} で発見！")
                print(f"フラグ長: {len(flag_bytes)} バイト")
                print(f"フラグ: {flag_str}")
                break
        except:
            pass
    
    # 進捗表示
    if k % 1000 == 0 and k > 0:
        print(f"探索中... k = {k}")

else:
    print("k = 0-9999 の範囲でフラグが見つかりませんでした。")
    print("範囲を広げる必要があるかもしれません。")
    print()
    print(f"参考: k=0 の場合のバイト列長 = {len(long_to_bytes(m_mod_N))}")
    print(f"      k=1 の場合のバイト列長 = {len(long_to_bytes(N + m_mod_N))}")
    print(f"      k=100000 の場合のバイト列長 = {len(long_to_bytes(100000*N + m_mod_N))}")
    print(f"      k=100000000 の場合のバイト列長 = {len(long_to_bytes(100000000*N + m_mod_N))}")
