from Crypto.Util.number import long_to_bytes

# 暗号化プログラムから出力された値
N = 65667982563395257456152578363358687414628050739860770903063206052667362178166666380390723634587933595241827767873104710537142458025201334420236653463444534018710274020834864080096247524541536313609304410859158429347482458882414275205742819080566766561312731091051276328620677195262137013588957713118640118673
e = 65537
c = 58443816925218320329602359198394095572237417576497896076618137604965419783093911328796166409276903249508047338019341719597113848471431947372873538253571717690982768328452282012361099369599755904288363602972252305949989677897650696581947849811037791349546750246816657184156675665729104603485387966759433211643
d = 14647215605104168233120807948419630020096019740227424951721591560155202409637919482865428659999792686501442518131270040719470657054982576354654918600616933355973824403026082055356501271036719280033851192012142309772828216012662939598631302504166489383155079998940570839539052860822636744356963005556392864865

# 復号化
m = pow(c, d, N)
flag_bytes = long_to_bytes(m)

print("デバッグ情報:")
print(f"復号化された数値 m: {m}")
print(f"バイト列の長さ: {len(flag_bytes)}")
print(f"最初の20バイト (hex): {flag_bytes[:20].hex()}")
print(f"最初の20バイト (raw): {flag_bytes[:20]}")
print()

# 検証: e と d が正しいか確認
print("検証:")
# c = m^e mod N なので、m = c^d mod N が正しければ、
# (m^e mod N) == c になるはず
verify = pow(m, e, N)
print(f"検証結果 (c^d)^e == c: {verify == c}")
print()

# 様々なエンコーディングで試してみる
print("デコード試行:")
for encoding in ['utf-8', 'latin-1', 'ascii', 'cp932']:
    try:
        decoded = flag_bytes.decode(encoding)
        print(f"{encoding}: 成功 - {decoded[:50]}...")
    except Exception as e:
        print(f"{encoding}: 失敗 - {e}")

# バイト列をそのまま表示
print(f"\nバイト列 (repr): {repr(flag_bytes)}")
